
1. 内存栈中的变量被释放实际上只是调整了栈顶指针的位置，栈中的内容并没有消失，还是会被访问到
2. NSTaggedPointerString
指针地址首位确定类型，是string、date还是number
如果是字符串，最后一位存储字符串长度
其余位利用ASCII码编码值来存储字符
正常一个字符占用1个字节，当超过7个字符时，采用6bit编码，也存在5bit编码，不过并不包含所有的字符


- 数组
线性表结构：数组，链表，栈，队列
数组从0开始编号，0表示的是偏移量，第0个位置的元素偏移量是0
数组的删除操作可以标记被删除的位置，待数组容量不够时，统一删除，可以提高性能。有点像GC的标记回收内存操作

- 链表
链表的插入、删除操作本身时间复杂度是O(1)，但是如过考虑到查找到相关的位置，时间复杂度就变成O(n)了。

- 栈
浏览器的前进后退
括号匹配
表达式求值
函数调用

- 队列
应用：线程池，生产者消费者
循环队列
阻塞队列
线程安全的并发队列（第54讲）

- 递归
1. 一个问题的解可以分解为几个子问题的解
2. 该问题和分解后的子问题除了规模不同，求解思路完全相同
3. 存在终止条件
注意栈溢出，因为每次递归调用的临时变量都会压栈，多次递归后栈规模扩大，存在溢出的风险
注意重复计算，子问题可能会互相包含，重复计算导致时间和空间复杂度上升，可以保存子问题结果来优化
注意脏数据导致的环导致的无限递归

- 排序
冒泡排序，插入排序，选择排序，希尔排序
归并排序，快速排序
桶排序，计数排序：数据的范围比较小
基数排序：可以拆分来排序，比如电话号码排序，可以从低位开始一位一位排序
是否是原地排序
排序的稳定性
通常我们使用的高级语言自带的排序功能底层使用的是快速排序，通过三数取中选择分区点
c语言的qsort()，在数据量小的时候使用归并排序，大的时候使用快速排序，自己在堆上模拟调用栈，快速排序一个分区中如果待排序数量少于4，会使用插入排序

- 二分查找
原数据有序，数组，不能是链表，因为需要通过下标查找
适用插入、删除操作不频繁的场景，否则维护一个有序数列会花费过多的时间
如果比较操作很耗时，推荐适用二分查找
数据量太大，也不适合，因为需要连续的存储空间
查找第一个值等于给定值的元素
查找最后一个值等于给定值的元素
查找第一个大于等于给定值的元素
查找最后一个小于等于给定值的元素

- 跳表
Redis的有序集合就使用了散列表+跳表来实现
构建了多层索引，用空间换时间的思路

- 散列表
解决散列冲突的两种方法：
1. 开放寻址法
适用于小对象，小数据量，装载因子较小
2. 拉链法：
适用于大对象，大数据量，链表数据较多(比如超过8)时，可以使用红黑树进行优化
使用链表来存，而没有使用数组，应该是出于如下考虑：没有通过index查询数据的需求，数组空间需要连续，可能经常需要扩容

散列表因装载因子过大而扩容时，可以不一次性完成扩容，将扩容操作穿插在插入操作中，每插入一个数据到新表时从老数据中转移一个数据到新表中，这样每次插入的时间可以维持在O(1)。
查询时，先查询新表，再查询老表。只不过无法一次性释放老表的内存。

散列表+双向链表：实现高效的LRU缓存淘汰系统，YYMemoryCache就是使用的这个策略


- 哈希算法
安全加密
数据校验
唯一标示
散列函数
负载均衡
数据分片
分布式存储

升级版：一致性哈希算法


- 树
为什么使用二叉查找树，而不用散列表？
1. 散列表的数据是无序的
2. 散列表扩容耗时
3. 散列表查找性能不稳定，出现散列冲突时，耗时增加
4. 构造散列表需要考虑的东西比较多

二叉树
二叉查找树：支持插入、删除、查找，中序遍历二叉查找树可以输出有序序列，
平衡二叉树：二叉树中任意一个节点的左右子树的高度相差不能大于1，比如：AVL树
红黑树：一种近似的平衡二叉树，广泛用在C++的STL中。如map和set都是用红黑树实现的。
B树
B+树：mysql索引，主键是聚集索引，自己额外添加的索引是非聚集所以，通过非聚集索引定位到主键，再通过聚集索引查找到记录