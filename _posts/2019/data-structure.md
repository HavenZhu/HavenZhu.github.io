
1. 内存栈中的变量被释放实际上只是调整了栈顶指针的位置，栈中的内容并没有消失，还是会被访问到
2. NSTaggedPointerString
指针地址首位确定类型，是string、date还是number
如果是字符串，最后一位存储字符串长度
其余位利用ASCII码编码值来存储字符
正常一个字符占用1个字节，当超过7个字符时，采用6bit编码，也存在5bit编码，不过并不包含所有的字符


- 数组
线性表结构：数组，链表，栈，队列
数组从0开始编号，0表示的是偏移量，第0个位置的元素偏移量是0
数组的删除操作可以标记被删除的位置，待数组容量不够时，统一删除，可以提高性能。有点像GC的标记回收内存操作

- 链表
链表的插入、删除操作本身时间复杂度是O(1)，但是如过考虑到查找到相关的位置，时间复杂度就变成O(n)了。

- 栈
浏览器的前进后退
括号匹配
表达式求值
函数调用

- 队列
应用：线程池，生产者消费者
循环队列
阻塞队列
线程安全的并发队列（第54讲）

- 递归
1. 一个问题的解可以分解为几个子问题的解
2. 该问题和分解后的子问题除了规模不同，求解思路完全相同
3. 存在终止条件
注意栈溢出，因为每次递归调用的临时变量都会压栈，多次递归后栈规模扩大，存在溢出的风险
注意重复计算，子问题可能会互相包含，重复计算导致时间和空间复杂度上升，可以保存子问题结果来优化
注意脏数据导致的环导致的无限递归

- 排序
冒泡排序，插入排序，选择排序，希尔排序
归并排序，快速排序
桶排序，计数排序：数据的范围比较小
基数排序：可以拆分来排序，比如电话号码排序，可以从低位开始一位一位排序
是否是原地排序
排序的稳定性
通常我们使用的高级语言自带的排序功能底层使用的是快速排序，通过三数取中选择分区点
c语言的qsort()，在数据量小的时候使用归并排序，大的时候使用快速排序，自己在堆上模拟调用栈，快速排序一个分区中如果待排序数量少于4，会使用插入排序

- 二分查找
原数据有序，数组，不能是链表，因为需要通过下标查找
适用插入、删除操作不频繁的场景，否则维护一个有序数列会花费过多的时间
如果比较操作很耗时，推荐适用二分查找
数据量太大，也不适合，因为需要连续的存储空间
查找第一个值等于给定值的元素
查找最后一个值等于给定值的元素
查找第一个大于等于给定值的元素
查找最后一个小于等于给定值的元素
