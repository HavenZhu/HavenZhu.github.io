---
layout: post
title: 编译与静态链接
category: Compile
tags: [Compile]
---

作为一名页面仔，在正常开发过程中极少与编译和链接打交道。只知道xcode的run成功之后就把app安装到手机上了。那么run究竟做了哪些事情呢？

其实主要就做了这么几件事：
- 编译
- 静态链接
- 代码签名
- 动态链接

这篇就先探讨一下编译和静态链接。


## 编译

至今还记得读本科时的三大"挂王"，编译原理就名列其中。研究生复试时也被问到了相关内容，这玩意就是临时抱佛脚看两眼，看完就忘了，因为实在是用不到。今天就再来复习一下吧。

编译可以分为以下几个部分：
- 预编译
- 词法分析
- 语法分析
- 语义分析
- 生成中间代码及优化
- 目标代码生成
- 目标代码优化

#### 预编译

预编译可以理解为编译前的准备工作，主要完成这么几件事：

> - 删除所有的#define，展开所有的宏定义
> - 处理条件编译指令，比如#if, #else, #endif等
> - 处理所有的#include预编译指令，将被include的文件插入到预编译指令的位置
> - 删除所有的注释
> - 添加行号和文件名标识，用于编译器产生调试用的行号信息以及编译时给出的错误和警告的行号信息
> - 保留所有的#pragma指令，编译器会使用


#### 词法分析、语法分析

这2点就不展开了，都是对源代码进行一些改写，生成抽象语法数。

#### 语义分析

前两步只是改造源代码，并不对源代码是否有误进行判断，此处会进行一些类型检查，比如把int付给了string，会给出错误提示。

#### 生成中间代码及优化

之所以存在中间代码，是为了解决多源语言，多机器的问题，使用不同高级语言编写的代码，编译完之后需要运行在不同的机器之上。

如果不存在中间代码，编译器需要为每个源语言+机器的组合实现一个单独的版本，这显然不现实。

有了中间代码，编译器前端负责将不同的源代码生成统一的中间代码，编译器后端负责将中间代码生成不同的目标机器码。当增加一种高级语言时，增加一套前端；增加一种机器时，增加一套后端。

代码优化包括：代码外提，删除无用代码，删除公共子表达式等。

- 代码外提：主要在循环结构中使用，这样能成倍的提高代码的运行效率。
- 删除公共表达式：对于相同的三地址代码可以进行合并，删除。
- 删除无用代码：对于一些临时变量和没有使用的代码可以进行删除。

补充一点，这里所说的机器并不是增加一个型号就多了一种，本质上是指不同的目标文件格式。常见的比如linux上的ELF，windows上的PE，OS X上的mach-o。这些都属于coff格式。关于目标文件的格式这里就不展开说了。

#### 目标代码生成

这一步已经是编译器后端做的事了，其实就是把一条一条的中间代码翻译成机器指令。

#### 目标代码优化

本质上和中间代码优化的目的是一致的，只是针对的是不同的代码。


## 静态链接

编译的结果是生成目标文件，静态链接的就是把很多个目标文件或者库合并起来生成可执行文件。

看到这里可能会有这样的疑问，为什么要区分编译和链接的过程呢？举个例子，在oc中，每个.m文件都会被编译成一个.o文件，再进行链接。为什么不直接把所有的文件编译到一起，再把链接的过程也包含进去呢？

其实我们在日常工作中已经享受过这样做的好处了。我们都知道首次点击run的时候，需要较长的时候才能把app安装到手机上，后续修改了某个文件之后再点击run，速度就会快很多。这就是因为已经编译好的文件不需要再次编译了，只需要编译被修改的文件，再进行链接就可以了。如果不把编译按文件进行分割，就没法做到这一点。

回归正题，静态链接的过程可以分为以下2块：
- 空间与地址分配
- 符号解析与重定位

符号在这里指的是一个变量或者一个函数，只有全局变量才需要在链接时处理，局部变量的地址在编译时就已经确定了。

所以一个直接的问题就是，全局符号的地址是怎么确定的？

#### 空间与地址分配

想要清楚的理解静态链接的过程，需要对目标文件有一定的理解。上面提到过常用的目标文件格式。其实链接生成的可执行文件也是相同的格式。就以目标文件为例吧。

目标文件是编译的结果。所以可以预料到目标文件中一定包含所有的代码。事实确实如此，只不过是加工后的代码。

目标文件将处理后的内容按段(segment)的形式进行存储，比如代码段，数据段，包含所有符号的符号表，字符串表，包含需要重定位信息的重定位表等等。

链接的时候，将多个目标文件中相同的段进行合并，例如所有的代码段会合成一个大的代码段，所有的符号也会合并到一个全局符号表中。当合并的过程完成之后，每个段的大小和起始位置就确定下来了，这些信息会存在表头中(ELF文件是表头，mach-o是load command)。

#### 符号解析与重定位

这一步是静态链接的关键，当一个编译单元引用其他编译单元的内容，在编译时是无法确定引用的符号的位置的，所以在目标文件中，该符号的地址就是0。同时编译器会在重定位表中记录相关的符号和该符号的入口地址，留作链接的时候使用。

经过上一步的地址分配，符号表中每个符号的地址已经确定了，这时在重定位表中寻找需要重定位的符号，根据入口地址可以找到符号的位置，再使用符号表中已经确定的地址替换原有的0，就完成了重定位的过程。


