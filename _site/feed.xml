<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>虚空</title>
    <description>闲来无事，随便写写</description>
    <link>http://47.100.168.106/</link>
    <atom:link href="http://47.100.168.106/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 25 Jul 2018 14:52:14 +0800</pubDate>
    <lastBuildDate>Wed, 25 Jul 2018 14:52:14 +0800</lastBuildDate>
    <generator>Jekyll v3.8.3</generator>
    
      <item>
        <title>我想做的一个改变</title>
        <description>&lt;p&gt;从没想过有一天我也会开始写字。决定写这一篇是因为昨天碰到一些事，这些事对我感触挺大，想记录一下自己的想法。&lt;/p&gt;

&lt;h2 id=&quot;题外话&quot;&gt;题外话&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;我自认为我的文字应该还是有初中水准的，如果我高估了还请高抬贵手不要打击我。不过不投稿的文章估计也没啥人看到，哈哈。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其实从小学开始我就感慨为什么会有语文这门课呢。因为那些阅读理解我实在是没法理解，真的就没有对过。&lt;/p&gt;

&lt;p&gt;高考结束的时候就想着这辈子终于可以不用再学语文了，结果大一上学期居然还有语文，本科、硕士毕业的时候也要写毕业论文。还记得写硕士论文的时候导师给我的评价永远都有：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;文字表述不规范，需要精炼。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我一个学软件工程的，还是写代码来的舒服。&lt;/p&gt;

&lt;h2 id=&quot;改变&quot;&gt;改变&lt;/h2&gt;

&lt;p&gt;以前，在社交软件里，我极少点赞，从不发表评论。这个习惯我准备改一改。&lt;/p&gt;

&lt;p&gt;在简书上，我看到很多坚持写作的人，他们并不知道坚持能不能成功，但依然在坚持着。有很多写了几万，十几万字的人，每篇文章的阅读量、点赞数都寥寥无几，但他们依然在坚持。我对他们一无所知，但我被他们这个行为震撼了。&lt;/p&gt;

&lt;p&gt;在看文章的过程中，我发现：&lt;strong&gt;一个赞，一句正面的评论可以给作者巨大的力量和鼓舞。同样，一句负面的评论也可能带来巨大的伤害。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我是一个内心特别强大的人，我有自己的行事准则，我根本不在意别人对我的看法。并不是所有人都跟我一样，但这并不能说他们很弱小，仅仅根据一件事情没法轻易的评判他人。&lt;/p&gt;

&lt;p&gt;在这里，我见识到了文字的强大，我想把我从文字中获取的能量传递出去，如果能鼓舞、帮助到别人，那就更好了。&lt;/p&gt;

&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;

&lt;p&gt;这个社会是很操蛋的，每天都会碰到很操蛋的事，遇见很操蛋的人，偶尔还会有一些操蛋的长辈对你的生活提出一些操蛋的意见。&lt;/p&gt;

&lt;p&gt;凭借个人的力量很难改变这个社会，但至少我不能让它变得更差。这是我坚持的动力。&lt;/p&gt;

&lt;p&gt;唯刀百辟，唯心不易。&lt;/p&gt;
</description>
        <pubDate>Fri, 03 Mar 2017 00:00:00 +0800</pubDate>
        <link>http://47.100.168.106/%E9%9A%8F%E7%AC%94/2017/03/03/%E6%88%91%E6%83%B3%E5%81%9A%E7%9A%84%E4%B8%80%E4%B8%AA%E6%94%B9%E5%8F%98.html</link>
        <guid isPermaLink="true">http://47.100.168.106/%E9%9A%8F%E7%AC%94/2017/03/03/%E6%88%91%E6%83%B3%E5%81%9A%E7%9A%84%E4%B8%80%E4%B8%AA%E6%94%B9%E5%8F%98.html</guid>
        
        <category>随笔</category>
        
        
        <category>随笔</category>
        
      </item>
    
      <item>
        <title>Runtime源码 —— 对象、类和isa</title>
        <description>&lt;p&gt;类、对象、方法和属性算是写OC代码时接触的最多的部分了。本篇就以对象为切入点，分析一下对象和类在runtime层面的表示。&lt;/p&gt;

&lt;p&gt;犹记得当初学习C++的时候，买过一本侯捷老师的《STL源码剖析》，书里的内容基本没看，就记得最前面有句话：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;源码面前，了无秘密&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;对象&quot;&gt;对象&lt;/h2&gt;
&lt;p&gt;继承于NSObject的类所生成的对象在runtime中的表示是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct objc_object {
    isa_t isa;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很简单，就一个isa_t结构体，从名字也可以看出来这个结构体指明了这个对象是什么，也就是所属的类，isa_t结构体的定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;union isa_t {
    Class cls;
    ...
}
(当然不止这么点内容，后面会详细的分析)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到这个结构体中有个类型是Class的属性cls，看起来里面应该存有关于这个对象的类的相关信息，看看Class是如何定义的。&lt;/p&gt;

&lt;h2 id=&quot;类&quot;&gt;类&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;typedef struct objc_class *Class;
struct objc_class : objc_object {
    Class superclass;
    cache_t cache;             // formerly cache pointer and vtable
    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Class就是结构体objc_class，但是objc_class继承于objc_object，那就是说类其实也是一个对象，只不过比通常我们理解的对象多了一些属性，比如superclass等。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;关于其他属性的分析不是本文重点，会在后续文章中结合方法(method)的实现进行分析。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;先不看这些属性，这里还有一个很奇怪的问题，既然类也是一个objc_object，那就是说类也有一个isa指针，那类的isa指针指向哪里呢？查看了不少资料，这篇讲的挺好：&lt;a href=&quot;http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html&quot;&gt;classes and metaclasses&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;大致的意思是在class之上，还有叫做元类(meta class)的存在，而class的isa指针就是指向对应的meta class。&lt;/p&gt;

&lt;p&gt;我们都知道class中存储的是描述对象的相关信息，那么相应的meta class中存放的就是描述class相关信息。说的更直白一点，在我们写代码时，通过对象来调用的方法（实例方法）都是存储在class中的，通过类名来调用的方法（类方法）都是存储在meta class中的。&lt;/p&gt;

&lt;p&gt;到这里对象和类的关系已经比较清楚了，但是如果细细思考一下，会发现还有一个问题，就是meta class也是有isa指针的，那么这个isa又指向了哪里呢？在上面给出的那篇文章里面有这么一张图：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;http://47.100.168.106/assets/images/2017_02_12/class_diagram.jpeg&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;这张图解释的非常清楚，meta class的isa指向了root meta class(绝大部分情况下root class就是NSObject)，root meta class的isa指向自身，isa的链路就是这样了。&lt;/p&gt;

&lt;h2 id=&quot;isa_t结构体分析&quot;&gt;isa_t结构体分析&lt;/h2&gt;
&lt;p&gt;先看看isa_t的完全版，因为运行环境是osx，所以只截取x86_64部分，arm64的区别只在于部分字段的位数不同，字段是完全相同的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;union isa_t 
{
    isa_t() { }
    isa_t(uintptr_t value) : bits(value) { }

    Class cls;
    uintptr_t bits;

#   __x86_64__
#   define ISA_MASK        0x00007ffffffffff8ULL
#   define ISA_MAGIC_MASK  0x001f800000000001ULL
#   define ISA_MAGIC_VALUE 0x001d800000000001ULL
    struct {
        uintptr_t nonpointer        : 1;
        uintptr_t has_assoc         : 1;
        uintptr_t has_cxx_dtor      : 1;
        uintptr_t shiftcls          : 44; 
        uintptr_t magic             : 6;
        uintptr_t weakly_referenced : 1;
        uintptr_t deallocating      : 1;
        uintptr_t has_sidetable_rc  : 1;
        uintptr_t extra_rc          : 8;
#       define RC_ONE   (1ULL&amp;lt;&amp;lt;56)
#       define RC_HALF  (1ULL&amp;lt;&amp;lt;7)
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看这个定义只能大概看出个框架，下面从isa的初始化过程来看看isa_t究竟是如何存储类或者元类的相关信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;inline void 
objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)
{
    initIsa(cls, true, hasCxxDtor);
}

inline void 
objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) 
{ 
    if (!nonpointer) {
        isa.cls = cls;
    } else {
        isa_t newisa(0);
        newisa.bits = ISA_MAGIC_VALUE;
        newisa.has_cxx_dtor = hasCxxDtor;
        newisa.shiftcls = (uintptr_t)cls &amp;gt;&amp;gt; 3;
        isa = newisa;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上来就看不懂，nonpointer是个什么，为什么在这里传的是true？在之前那位大神的另一篇文章中也有解释：&lt;a href=&quot;http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html&quot;&gt;Non-pointer isa&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;大概的意思是在64位系统中，为了降低内存使用，提升性能，isa中有一部分字段用来存储其他信息。这也解释了上面isa_t的那部分结构体。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;这有点像taggedPointer，两者之间有什么区别？备注一下后面再研究。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在知道了nonpointer为什么是true，那么把initIsa方法先简化一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;inline void 
objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) 
{ 
    isa_t newisa(0);
    newisa.bits = ISA_MAGIC_VALUE;
    newisa.has_cxx_dtor = hasCxxDtor;
    newisa.shiftcls = (uintptr_t)cls &amp;gt;&amp;gt; 3;
    isa = newisa;
}

#   define ISA_MAGIC_VALUE 0x001d800000000001ULL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一共三部分：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;newisa.bits = ISA_MAGIC_VALUE;
从ISA_MAGIC_VALUE的定义中可以看到这个字段初始化了两个部分，一个是magic字段(6位:111011)，一个是nonpointer字段(1位:1)，magic字段用于校验，nonpointer之前已经详细分析过了。&lt;/li&gt;
  &lt;li&gt;newisa.has_cxx_dtor = hasCxxDtor;
这个字段存储类是否有c++析构器。&lt;/li&gt;
  &lt;li&gt;newisa.shiftcls = (uintptr_t)cls » 3;
将cls右移3位存到shiftcls中，从isa_t的结构体中也可以看到低3位都是用来存储其他信息的，既然可以右移三位，那就代表类地址的低三位全部都是0，否则就出错了，补0的作用应该是为了字节对齐。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因为nonpointer的缘故，isa并不只是用来存储类地址了，所以需要提供一个额外的方法来返回真正的地址：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;inline Class 
objc_object::ISA() 
{
    return (Class)(isa.bits &amp;amp; ISA_MASK);
}

#   define ISA_MASK        0x00007ffffffffff8ULL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实就是取isa_t结构体的shiftcls字段。&lt;/p&gt;

&lt;h3 id=&quot;其他字段&quot;&gt;其他字段&lt;/h3&gt;
&lt;p&gt;还有一些其他的字段，把上面那篇文章中相关部分翻译过来放在下面：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;// 是否曾经或正在被关联引用，如果没有，可以快速释放内存
uintptr_t has_assoc         : 1;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;// 对象是否曾经或正在被弱引用，如果没有，可以快速释放内存
uintptr_t weakly_referenced : 1;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;// 对象是否正在释放内存
uintptr_t deallocating      : 1;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;// 对象的引用计数太大，无法存储
uintptr_t has_sidetable_rc  : 1;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;// 对象的引用计数超过1，比如10，则此值为9
uintptr_t extra_rc          : 8;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;例子&quot;&gt;例子&lt;/h2&gt;
&lt;p&gt;下面通过代码验证一下之前关于isa的链路，先创建一个用于测试TestObject类，相关代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// TestObject.h
#import &amp;lt;Foundation/Foundation.h&amp;gt;
@interface TestObject : NSObject

@end

// TestObject.m
#import &quot;TestObject.h&quot;
@implementation TestObject

@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了方便打条件断点，先通过log获取TestObject在内存中的位置：0x100001180，这个时候main函数是这个样子的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int main(int argc, const char * argv[]) {
    @autoreleasepool {
        TestObject *testObj = [TestObject new];
        NSLog(@&quot;%p&quot;, [testObj class]);
        NSLog(@&quot;%p&quot;, [TestObject class]);
        NSLog(@&quot;%p&quot;, [NSObject class]);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;只要代码不变，这个类在内存中的地址就不会变&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以在initIsa()方法中添加一个条件断点，并重新运行：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;http://47.100.168.106/assets/images/2017_02_12/1.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;运行程序，当进入断点的时候可以看到方法的调用栈是这样的：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;http://47.100.168.106/assets/images/2017_02_12/2.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;找到2 _class_createInstanceFromZone()，在方法最后打个断点，继续运行程序进入此断点，输出obj的内存地址：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Printing description of obj:
&amp;lt;TestObject: 0x101301090&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来通过这个地址来测试一下isa的链路：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//方法中的obj类型是id，id就是objc_object*，所以强转一下
(lldb) p (objc_object *)0x101301090
(objc_object *) $3 = 0x0000000101301090
(lldb) p $3-&amp;gt;isa 
(objc_class *) $4 = 0x001d800100001181 // 对象的isa
(lldb) p (objc_object *)0x100001180 // 根据上面isa_t结构体，找到shiftcls的地址，也就是类的真实地址
(objc_object *) $5 = 0x0000000100001180 // TestObject类的真实地址，可以看到与之前打印的[TestObject class]地址是相同的
(lldb) p $5-&amp;gt;isa
(objc_class *) $6 = 0x001d800100001159 // 类的isa
(lldb) p (objc_object *)0x100001158
(objc_object *) $7 = 0x0000000100001158 // TestObject元类的真实地址
(lldb) p $7-&amp;gt;isa
(objc_class *) $8 = 0x001d8001004a0e49 // 根元类的isa
(lldb) p (objc_object *)0x1004a0e48
(objc_object *) $9 = 0x00000001004a0e48
(lldb) p $9-&amp;gt;isa
(objc_class *) $10 = 0x001d8001004a0e49 // 可以看到根元类的isa确实指向自身
(lldb) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试结果与图class diagram.jpeg给出的完全相同。&lt;/p&gt;

&lt;p&gt;在main函数的return行添加断点，运行程序进入断点，有如下输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSLog(@&quot;%p&quot;, [testObj class]); 
NSLog(@&quot;%p&quot;, [TestObject class]);
NSLog(@&quot;%p&quot;, [NSObject class]); 

log输出：
0x100001180
0x100001180
0x1004a0e98
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前两个log结果相同，稍后再分析，这里先看一下NSObject的元类isa：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(lldb) p (objc_object *)0x1004a0e98
(objc_object *) $11 = 0x00000001004a0e98
(lldb) p $11-&amp;gt;isa
(objc_class *) $12 = 0x001d8001004a0e49
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到此处$12的值与上方$10是完全相同的，也就验证了NSObject的meta class就是一般类的root meta class。&lt;/p&gt;

&lt;p&gt;下面再来看看上面那两个相同的输出，也就是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TestObject *testObj = [TestObject new];
NSLog(@&quot;%d&quot;, [testObj class] == [TestObject class]);

这个log会输出1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看起来有点奇怪，但是只要看一下源代码实现就能理解了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (Class)class {
    return self;
}

- (Class)class {
    return object_getClass(self);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;object_getClass方法最终返回的是isa。所以TestObject调用class方法，返回的是自身；testObj调用class方法，返回的是isa指向的类，也是TestObject。所以上面结果相同就不奇怪了。&lt;/p&gt;

&lt;p&gt;看到这里就顺便看一下可能会接触到isa的常用的几个方法：isMemberOfClass，isKindOfClass。废话不说，直接上源码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (BOOL)isMemberOfClass:(Class)cls {
    return object_getClass((id)self) == cls;
}

- (BOOL)isMemberOfClass:(Class)cls {
    return [self class] == cls;
}

+ (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&amp;gt;superclass) {
        if (tcls == cls) return YES;
    }
    return NO;
}

- (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = [self class]; tcls; tcls = tcls-&amp;gt;superclass) {
        if (tcls == cls) return YES;
    }
    return NO;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从源码来看这两个方法就一目了然了。有兴趣的可以写几个例子测试一下。&lt;/p&gt;
</description>
        <pubDate>Sun, 12 Feb 2017 00:00:00 +0800</pubDate>
        <link>http://47.100.168.106/runtime%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/2017/02/12/Runtime%E6%BA%90%E7%A0%81-%E5%AF%B9%E8%B1%A1-%E7%B1%BB%E5%92%8Cisa.html</link>
        <guid isPermaLink="true">http://47.100.168.106/runtime%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/2017/02/12/Runtime%E6%BA%90%E7%A0%81-%E5%AF%B9%E8%B1%A1-%E7%B1%BB%E5%92%8Cisa.html</guid>
        
        <category>Runtime</category>
        
        
        <category>Runtime源码阅读</category>
        
      </item>
    
      <item>
        <title>Runtime源码 —— 概述和调试环境准备</title>
        <description>&lt;p&gt;关于runtime的文章已经有很多很多了，有些也写的很详细，但纸上得来终觉浅，我还是决定自己动手学一学，并且记录下这个过程。&lt;/p&gt;

&lt;p&gt;这一系列准备写的内容，更多的是写给我自己看。&lt;/p&gt;

&lt;p&gt;第一篇文章，决定写写OC的运行时，也就是runtime。
这东西正常几乎接触不到，最常用的应该算是在category中添加property时，使用的AssociatedObject。苹果自己在&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1&quot;&gt;runtime官方文档&lt;/a&gt;中也说了：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Typically, though, there should be little reason for you to need to know and understand this material to write a Cocoa application.&lt;/p&gt;

  &lt;p&gt;翻译：会不会这玩意儿无关紧要。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但毕竟runtime也算是整个OC的基础，理解runtime对理解这门语言有很大的帮助，我也想以此为切入点，提高一下阅读源码的能力。&lt;/p&gt;

&lt;p&gt;runtime的内容很多，一篇肯定写不完，本文先就目前我对runtime的理解做一点简单的介绍，后面随着源码的阅读会分成多篇来详细分析。&lt;/p&gt;

&lt;h2 id=&quot;runtime概述&quot;&gt;runtime概述&lt;/h2&gt;

&lt;p&gt;OC是一门动态语言，OC尽可能多的将工作留到了运行时，而不是在编译期和链接期，这赋予了OC很多强大的功能，这也是runtime所要做的工作。&lt;/p&gt;

&lt;p&gt;runtime可以看做是一个库，主要由c和汇编来实现，我们在OC里面所写的类，方法，属性等等在runtime层面都会转化成c的结构体。
官方文档中说通常我们会通过三个方面与runtime打交道：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;OC源代码&lt;/li&gt;
    &lt;li&gt;NSObject提供的相关方法&lt;/li&gt;
    &lt;li&gt;runtime库提供的各种api&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;第1个方面就不说了，第2和第3部分是这个系列的重点。我会分析正常写OC代码接触较多的，比如类（class），方法（method），属性（property），协议（protocol），分类（category），自动释放池（autoreleasepool），引用计数（retain，release等），初始化（load，alloc，init，new等）等这些内容的源代码。&lt;/p&gt;

&lt;p&gt;希望通过对runtime的研究能够加深对OC的理解，戒掉浅尝辄止的坏毛病，走上造轮子的道路。&lt;/p&gt;

&lt;h2 id=&quot;调试环境准备&quot;&gt;调试环境准备&lt;/h2&gt;

&lt;p&gt;想要学习runtime，必须有一个可以运行的环境才行，苹果官方的源代码没法编译，这里有可以运行的&lt;a href=&quot;https://github.com/RetVal/objc-runtime&quot;&gt;runtime source code&lt;/a&gt;。在最新的Mac OS 10.12.2 + Xcode 8.2.1环境下有效。&lt;/p&gt;
</description>
        <pubDate>Fri, 10 Feb 2017 00:00:00 +0800</pubDate>
        <link>http://47.100.168.106/runtime%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/2017/02/10/Runtime%E6%BA%90%E7%A0%81-%E6%A6%82%E8%BF%B0%E5%92%8C%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87.html</link>
        <guid isPermaLink="true">http://47.100.168.106/runtime%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/2017/02/10/Runtime%E6%BA%90%E7%A0%81-%E6%A6%82%E8%BF%B0%E5%92%8C%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87.html</guid>
        
        <category>Runtime</category>
        
        
        <category>Runtime源码阅读</category>
        
      </item>
    
  </channel>
</rss>
